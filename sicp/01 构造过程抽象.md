    抽象很重要，它使得我们不用去理解很底层的知识（比如与非门、晶体管、CPU等等）、也不用重复地去发明轮子，就可以写出好的程序。因为前辈们给我们提供了一层一层的抽象，使得我们可以“开箱即用”。

    计算过程：由一系列对数据的操作所组成
    我们用程序设计语言来描述希望进行的计算过程。

    设计良好的计算系统就像设计良好的汽车或者核反应堆一样，具有某种模块化的设计，其中的各个部分都可以独立地构造、替换、排除错误。
    
    Lisp
        是20世纪50年代后期发明的一种记法形式，是为了能对某种特定形式的逻辑表达式（称为递归方程）的使用做推理。
    
    配置开发环境（vscode）：
        1、从 https://cisco.github.io/ChezScheme/ 下载Lisp解释器，安装并配置环境变量
        2、vscode安装插件：vscode-scheme, code runner
        3、vscode中，打开Settings，增加
            "code-runner.runInTerminal": true,
            "code-runner.executorMapByFileExtension": {
                    ".ss": "scheme"
                },
            "code-runner.executorMap" {
            "scheme": "scheme"  // 修改scheme对应的解释器
            ...
            },
    
    为什么用Lisp作为讨论程序设计的基础？
        因为Lisp中的一个重要特征：计算过程的Lisp描述（称为过程）本身又可以作为Lisp的数据来表示和操作，使得利用它可以非常方便地研究程序的设计、构造，以及各种数据结构。
    
    
    程序设计的基本元素
        描述一个语言的重点：它所提供的，能够将简单的认识组合起来形成更复杂认识的方法。
            基本表达形式，用于表示语言所关心的最简单的个体
            组合的方法，通过它们可以从较简单的东西出发构造出复合的元素
            抽象的方法，通过它们可以为复合对象命名，并将它们当作单元去操作
    
    过程和数据：数据是一种我们希望去操作的“东西”，而过程就是有关操作这些数据的规则的描述。
    
    组合式：(+ 123 456)、(* 5 9)，构造方式就是用一对括号括起一些表达式，形成一个表，用于表示一个过程应用。
    前缀表示：将运算符放在所有运算对象左边。(+ (* 3 5) (- 10 6))
    美观打印格式规则：各个运算对象垂直对齐
    (+
        (* 3
           (+ (* 2 4)
              (+ 3 5)))
        (+ (- 10 7)
           6))
    
    命名：(define count 0) (define result (* 2 3))
    
    我们可以将值与符号关联，而后又能提取出这些值，这意味着解释器必须维护某种存储能力，以便保持有关的名字-值对偶的轨迹。这种存储被称为环境。
    
    过程定义：(define (square x) (* x x))  定义了一个复合过程，用于求一个数的平方
    过程定义的一般形式：(define (<name> <formal parameters>) <body>)
    <name>符号：过程定义将在环境中关联这个符号
    x^2 + y^2：(+ (square x) (square y))
    (define (sum-of-squares x y)
        (+ (square x) (square y)))
    
    代换模型：如下描述的计算过程称为过程应用的代换模型
        (define (f a)
            (sum-of-squares (+ a 1) (* a 2)))
        求值: (f 5)
        提取出f的体：
            (sum-of-squares (+ a 1) (* a 2))
        用实参5代换其中的形参：
            (sum-of-squares (+ 5 1) (* 5 2))
        对运算符(sum-of-squares)求值，以便得到应该去应用的那个过程；还需要对两个运算对象求值，以得到实参：
            (+ (square 6) (square 10))
        再使用square的定义将它归约为：
            (+ (* 6 6) (* 10 10))
        进一步规约:
            (+ 36 100)
        最后得到：
            136
    
    
    正则序求值：完全展开而后规约
        (f 5)
        (sum-of-squares (+ 5 1) (* 5 2))
        (+ (square (+ 5 1)) (square (* 5 2)))
        (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
    而现在解释器里实际使用的是应用序求值：先求值参数而后应用
    
    cond(表示“条件”):
    (define (abs x)
        	 (cond ((> x 0) x)
                   ((= x 0) 0)
                   ((< x 0) (- x))))
    另一种形式：
    (define (abs x)
        (cond ((< x 0) (- x))
              (else x)))
    一般形式：
        (cond (<p1> <e1>)
              (<p2> <e2>)
              ...
              (<pn> <en>))
    符号cond之后，跟着一些称为子句的用括号括起来的表达式对偶(<p> <e>)。在每个对偶中的第一个表达式是一个谓词，也就是说，这是一个表达式，它的值将被解释为真或者假。
    
    if表达式的一般形式：(if <predicate> <consequent> <alternative>)
    在求值一个if表达式时，解释器从求值其<predicate>部分开始，如果<predicate>得到真值，解释器就去求值<consequent>并返回其值，否则它就去求值<alternative>并返回其值。